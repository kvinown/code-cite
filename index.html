<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<title>Code Cite</title>
		<meta
			name="viewport"
			content="width=device-width, initial-scale=1.0" />

		<!-- Tailwind (CDN) - hanya untuk demo/development -->
		<link
			href="./libs/tailwind/tailwind.min.css"
			rel="stylesheet" />

		<!-- Highlight.js -->
		<script src="./libs/dependencies/highlight.min.js"></script>
		<link
			rel="stylesheet"
			href="./libs/dependencies/atom-one-dark.min.css"
			type="text/css"
			title="Atom" />

		<!-- React & ReactDOM -->
		<script src="./libs/react/react.development.js"></script>
		<script src="./libs/react/react-dom.development.js"></script>

		<!-- Lucide Icons (UMD) -->
		<script src="./libs/dependencies/lucide.js"></script>

		<!-- JSZip -->
		<script src="./libs/dependencies/jszip.min.js"></script>
		<script src="./libs/dependencies/FileSaver.min.js"></script>

		<!-- Babel (compile JSX langsung di browser) -->
		<script src="./libs/babel/babel.min.js"></script>

		<link
			rel="stylesheet"
			href="style.css" />

		<!-- CSS BARU untuk Efek Flash -->
		<style>
			@keyframes flash-animation {
				0% {
					background-color: rgba(252, 211, 77, 0); /* yellow-300/0 */
				}
				25% {
					background-color: rgba(252, 211, 77, 0.6); /* yellow-300/60 */
				}
				75% {
					background-color: rgba(252, 211, 77, 0.6); /* yellow-300/60 */
				}
				100% {
					background-color: rgba(252, 211, 77, 0); /* yellow-300/0 */
				}
			}

			.flash-highlight {
				animation: flash-animation 1.5s ease-out;
			}
		</style>
	</head>
	<body class="bg-gray-100">
		<div id="root"></div>

		<!-- App -->
		<script type="text/babel">
			const { useState, useEffect, useRef } = React;
			//==================================================
			// Component: Header
			//==================================================
			window.Header = () =>
				React.createElement(
					"header",
					{ className: "bg-white shadow-sm" },
					React.createElement(
						"div",
						{ className: "max-w-7xl mx-auto py-4 px-4 sm:px-6 lg:px-8 flex justify-between items-center" },
						React.createElement(
							"div",
							{ className: "flex items-center" },
							React.createElement(
								"svg",
								{
									className: "w-10 h-10 text-cyan-500",
									viewBox: "0 0 24 24",
									fill: "none",
								},
								React.createElement("path", {
									d: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-1 15v-2h2v2h-2zm0-4v-6h2v6h-2z",
									fill: "currentColor",
								})
							),
							React.createElement("span", { className: "ml-3 text-2xl font-bold text-gray-800" }, "Code Cite")
						),
						React.createElement("div", { className: "text-gray-600" }, "Hello John Doe")
					)
				);

			//==================================================
			// Component: Header End
			//==================================================

			//==================================================
			// Component: Navbar
			//==================================================
			window.Navbar = () => {
				const navItems = ["Dashboard", "My Projects", "Account", "About", "Logout"];
				return React.createElement(
					"nav",
					{ className: "bg-cyan-600" },
					React.createElement(
						"div",
						{ className: "max-w-7xl mx-auto px-2 sm:px-6 lg:px-8" },
						React.createElement(
							"div",
							{ className: "relative flex items-center justify-start h-12" },
							React.createElement(
								"div",
								{ className: "flex items-center space-x-4" },
								navItems.map((item) =>
									React.createElement(
										"a",
										{
											key: item,
											href: "#",
											className: "text-white hover:bg-cyan-700 px-3 py-2 rounded-md text-sm font-medium",
										},
										item
									)
								)
							)
						)
					)
				);
			};

			//==================================================
			// Component: Navbar End
			//==================================================

			//==================================================
			// Component: Upload Screen
			//==================================================
			// Komponen Pesan Error
			const ErrorMessage = ({ message, onClear }) => {
				if (!message) return null;
				return React.createElement(
					"div",
					{ className: "mt-4 bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded relative", role: "alert" },
					React.createElement("span", { className: "block sm:inline" }, message),
					React.createElement(
						"span",
						{ className: "absolute top-0 bottom-0 right-0 px-4 py-3", onClick: onClear },
						React.createElement(
							"svg",
							{ className: "fill-current h-6 w-6 text-red-500", role: "button", xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 20 20" },
							React.createElement("title", null, "Close"),
							React.createElement("path", {
								d: "M14.348 14.849a1.2 1.2 0 0 1-1.697 0L10 11.819l-2.651 3.029a1.2 1.2 0 1 1-1.697-1.697l2.758-3.15-2.759-3.152a1.2 1.2 0 1 1 1.697-1.697L10 8.183l2.651-3.031a1.2 1.2 0 1 1 1.697 1.697l-2.758 3.152 2.758 3.15a1.2 1.2 0 0 1 0 1.698z",
							})
						)
					)
				);
			};

			window.UploadScreen = ({ onUpload }) => {
				const [file, setFile] = useState(null);
				const [projectName, setProjectName] = useState("");
				const [isDragging, setIsDragging] = useState(false);
				const [isUploading, setIsUploading] = useState(false);
				const [progress, setProgress] = useState(0);
				const [error, setError] = useState("");
				const fileInputRef = useRef(null);

				const handleFileSelect = (selectedFile) => {
					setError("");
					if (selectedFile && selectedFile.name.endsWith(".zip")) {
						setFile(selectedFile);
						if (!projectName) {
							setProjectName(selectedFile.name.replace(/\.zip$/, ""));
						}
					} else {
						setError("Hanya mendukung file .zip");
					}
				};

				const handleFileChange = (e) => {
					if (e.target.files.length > 0) {
						handleFileSelect(e.target.files[0]);
					}
				};

				const handleDrop = (e) => {
					e.preventDefault();
					setIsDragging(false);
					if (e.dataTransfer.files.length > 0) {
						handleFileSelect(e.dataTransfer.files[0]);
					}
				};

				const handleDragOver = (e) => {
					e.preventDefault();
					setIsDragging(true);
				};

				const handleDragLeave = () => {
					setIsDragging(false);
				};

				const handleSubmit = () => {
					if (file && projectName) {
						setIsUploading(true);
						setProgress(0);
						const interval = setInterval(() => {
							setProgress((prev) => {
								if (prev >= 100) {
									clearInterval(interval);
									setTimeout(() => {
										setIsUploading(false);
										onUpload(file, projectName);
									}, 500);
									return 100;
								}
								return prev + 10;
							});
						}, 100);
					} else {
						setError("Harap pilih file .zip dan beri nama proyek");
					}
				};

				const UploadIcon = () => React.createElement("i", { "data-lucide": "upload-cloud", className: isDragging ? "text-cyan-500" : "text-gray-400" });

				return React.createElement(
					"div",
					{ className: "bg-white p-8 rounded-lg shadow-lg max-w-2xl mx-auto text-center" },
					React.createElement("h2", { className: "text-2xl font-bold text-gray-800 mb-4" }, "Mulai Proyek Sitasi Baru"),
					React.createElement("p", { className: "text-gray-600 mb-6" }, "Beri nama proyek Anda dan unggah file .zip yang berisi kode sumber."),
					React.createElement(
						"div",
						{ className: "mb-4 text-left" },
						React.createElement("label", { htmlFor: "projectName", className: "block text-sm font-medium text-gray-700 mb-1" }, "Nama Proyek"),
						React.createElement("input", {
							type: "text",
							id: "projectName",
							value: projectName,
							onChange: (e) => setProjectName(e.target.value),
							className: "w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:ring-cyan-500 focus:border-cyan-500",
							placeholder: "Contoh: Tugas Akhir Bab 4",
						})
					),
					React.createElement(
						"div",
						{
							className: `border-2 border-dashed rounded-lg p-8 cursor-pointer transition-colors duration-200 flex flex-col items-center justify-center ${
								isDragging ? "border-cyan-500 bg-cyan-50" : "border-gray-300 bg-gray-50 hover:border-cyan-400"
							}`,
							onClick: () => fileInputRef.current.click(),
							onDrop: handleDrop,
							onDragOver: handleDragOver,
							onDragLeave: handleDragLeave,
						},
						React.createElement("input", { type: "file", accept: ".zip", ref: fileInputRef, onChange: handleFileChange, className: "hidden" }),
						React.createElement("div", { className: `mb-3 ${isDragging ? "animate-bounce" : ""}` }, React.createElement(UploadIcon)),
						file
							? React.createElement("p", { className: "text-gray-700" }, "File terpilih: ", React.createElement("span", { className: "font-semibold" }, file.name))
							: React.createElement("p", { className: "text-gray-500" }, "Klik atau drag & drop file ", React.createElement("span", { className: "font-semibold" }, ".zip"), " di sini")
					),
					React.createElement(ErrorMessage, { message: error, onClear: () => setError("") }),
					isUploading &&
						React.createElement(
							"div",
							{ className: "mt-6 w-full bg-gray-200 rounded-full h-3 overflow-hidden" },
							React.createElement("div", {
								className: "bg-cyan-600 h-3",
								style: { width: `${progress}%`, transition: "width 0.3s ease-in-out" },
							})
						),
					React.createElement(
						"button",
						{
							onClick: handleSubmit,
							disabled: !file || !projectName || isUploading,
							className: "mt-6 w-full bg-cyan-600 text-white font-bold py-3 px-4 rounded-md hover:bg-cyan-700 disabled:bg-gray-400 transition-colors",
						},
						isUploading ? "Mengupload..." : "Mulai Proses Sitasi"
					)
				);
			};

			//==================================================
			// Component: Upload Screen End
			//==================================================

			//==================================================
			// Helper: Auto Citation Parsers
			//==================================================

			/**
			 * Mengidentifikasi tipe file berdasarkan nama file.
			 * @param {string} fileName - Nama file (misal: "main.py", "App.java")
			 * @returns {string|null} - 'python', 'java', atau null
			 */
			function getFileType(fileName) {
				if (fileName.endsWith(".py")) {
					return "python";
				}
				if (fileName.endsWith(".java")) {
					return "java";
				}
				return null;
			}

			/**
			 * [FINAL UPGRADE]
			 * Mem-parsing konten kode untuk sitasi otomatis berdasarkan komentar.
			 * @param {string} codeContent - Seluruh isi file kode sebagai string.
			 * @param {string} fileType - Tipe file ('python' atau 'java').
			 * @returns {Array<Object>} - Array berisi objek sitasi yang ditemukan.
			 */
			function parseCitationsFromCode(codeContent, fileType) {
				const newCitations = [];
				if (!codeContent || !fileType) {
					return newCitations;
				}

				const lines = codeContent.split("\n");

				// Definisikan semua regex berdasarkan tipe file
				let commentPrefix, citeRegex, citeStartRegex, citeEndRegex, isCommentRegex, separatorRegex, commentPrefixRegex, keyValRegex;

				if (fileType === "python") {
					commentPrefix = "#";
					isCommentRegex = /^\s*#/;
				} else if (fileType === "java") {
					commentPrefix = "\/\/";
					isCommentRegex = /^\s*\/\//;
				} else {
					return newCitations; // Tipe file tidak didukung
				}

				// Regex dinamis berdasarkan prefix komentar
				citeRegex = new RegExp(`^\\s*${commentPrefix}\\s*CITE:\\s*(.*)$`, "i");
				citeStartRegex = new RegExp(`^\\s*${commentPrefix}\\s*CITE-START:\\s*(.*)$`, "i");
				citeEndRegex = new RegExp(`^\\s*${commentPrefix}\\s*CITE-END\\s*$`, "i");
				separatorRegex = new RegExp(`^\\s*${commentPrefix}\\s*---\\s*$`, "i");
				commentPrefixRegex = (fileType === "python") ? /^\s*#\s*/ : /^\s*\/\/\s*/;
				keyValRegex = /^\s*([a-zA-Z]+):\s*(.*)$/; // Regex untuk "Key: Value"

				// Loop utama
				for (let i = 0; i < lines.length; i++) {
					const line = lines[i];
					const lineNumber = i + 1; // 1-based index

					const citeStartMatch = line.match(citeStartRegex);
					const citeMatch = line.match(citeRegex);

					// --- Skenario 1 & 2: Blok Sitasi (CITE-START) ---
					if (citeStartMatch) {
						const firstLineText = citeStartMatch[1].trim(); // Teks di baris CITE-START:
						let sourceData = {};
						let metadataLines = [];
						let codeStartIndex = -1;

						// 1. Parse Metadata (baris antara CITE-START dan ---)
						let j;
						for (j = i + 1; j < lines.length; j++) {
							const currentLine = lines[j];
							if (citeEndRegex.test(currentLine)) break; // Menemukan CITE-END (tanpa kode)
							if (separatorRegex.test(currentLine)) {
								codeStartIndex = j + 1; // Kode dimulai setelah separator
								break;
							}
							metadataLines.push(currentLine); // Ini adalah baris metadata
						}

						if (j === lines.length) {
							// Tidak menemukan separator atau CITE-END
							console.warn(`CITE-START di baris ${lineNumber} tidak ditutup atau tidak memiliki separator '---'.`);
							continue;
						}

						// 2. Ekstrak data dari metadata
						let hasStructuredKeys = false;
						// Gabungkan teks dari baris CITE-START: dan baris metadata
						const allMetadataText = [firstLineText, ...metadataLines];

						for (const rawLine of allMetadataText) {
							let cleanLine = rawLine.replace(commentPrefixRegex, "").trim();
							const match = cleanLine.match(keyValRegex);

							if (match) {
								hasStructuredKeys = true;
								const key = match[1].trim().toLowerCase();
								const value = match[2].trim();
								if (key === "judul") sourceData.title = value;
								else if (key === "tipe") sourceData.type = value.toLowerCase();
								else if (key === "value") sourceData.value = value;
								else if (key === "notes") sourceData.notes = value;
							}
						}

						// 3. Tentukan Judul
						// Jika tidak ada 'Judul:' key, TAPI ada teks di baris CITE-START:, gunakan itu sebagai judul
						if (!sourceData.title && !hasStructuredKeys && firstLineText) {
							sourceData.title = firstLineText;
						}

						if (!sourceData.title) {
							console.warn(`CITE-START di baris ${lineNumber} tidak memiliki 'Judul:' atau teks judul sederhana.`);
							i = j; // Loncat ke separator/CITE-END
							continue;
						}

						// 4. Cek apakah ada blok kode
						if (codeStartIndex === -1) {
							console.warn(`CITE-START di baris ${lineNumber} tidak memiliki '---' separator untuk blok kode.`);
							i = j; // Loncat ke CITE-END
							continue;
						}

						// 5. Cari CITE-END untuk blok kode
						let codeEndIndex = -1;
						let k;
						for (k = codeStartIndex; k < lines.length; k++) {
							if (citeEndRegex.test(lines[k])) {
								codeEndIndex = k; // Kode berakhir di baris *sebelum* CITE-END
								break;
							}
						}

						if (codeEndIndex === -1) {
							console.warn(`CITE-START di baris ${lineNumber} tidak memiliki CITE-END setelah '---'.`);
							continue; // Biarkan loop 'i' berlanjut
						}

						// 6. Buat sitasi
						const codeBlock = lines.slice(codeStartIndex, codeEndIndex).join("\n");
						// Validasi: Jangan sitasi jika baris 'start' > 'end' (blok kode kosong)
						if (codeStartIndex >= codeEndIndex) {
							console.warn(`CITE-START di baris ${lineNumber} memiliki blok kode kosong.`);
							i = k; // Loncat ke CITE-END
							continue;
						}

						newCitations.push({
							start: codeStartIndex + 1, // 1-based
							end: codeEndIndex, // 1-based (baris terakhir kode adalah `k-1`, indexnya `k`)
							code: codeBlock,
							sourceData: sourceData, // Kirim objek lengkap
						});

						i = k; // Loncat loop utama ke CITE-END
					}
					// --- Skenario 3: Sitasi Satu Baris (CITE:) ---
					else if (citeMatch) {
						const sourceText = citeMatch[1].trim();
						if (!sourceText) continue; // Abaikan CITE: kosong

						let nextCodeLine = null;
						let nextCodeLineNumber = -1;

						// Cari baris kode valid berikutnya
						for (let j = i + 1; j < lines.length; j++) {
							const potentialCodeLine = lines[j];
							const isEmpty = potentialCodeLine.trim() === "";
							const isComment = isCommentRegex.test(potentialCodeLine.trim());

							// Cek apakah ini tag sitasi lain
							const isCiteTag =
								citeRegex.test(potentialCodeLine) ||
								citeStartRegex.test(potentialCodeLine) ||
								citeEndRegex.test(potentialCodeLine);

							if (!isEmpty && !isComment && !isCiteTag) {
								nextCodeLine = potentialCodeLine.trim();
								nextCodeLineNumber = j + 1; // 1-based
								break;
							}
						}

						if (nextCodeLine) {
							newCitations.push({
								start: nextCodeLineNumber,
								end: nextCodeLineNumber,
								code: nextCodeLine,
								sourceData: { title: sourceText }, // Format Cepat hanya punya judul
							});

							i = nextCodeLineNumber - 1; // Loncat ke baris kode yg baru disitasi
						}
					}
				}
				return newCitations;
			}
			//==================================================
			// Helper: Auto Citation Parsers End
			//==================================================

			//==================================================
			// Component: Workspace
			//==================================================
			const COLORS = ["bg-cyan-900/60", "bg-green-900/60", "bg-purple-900/60", "bg-pink-900/60", "bg-yellow-700/60"];

			/**
			 * Helper function untuk mencari file node di dalam tree berdasarkan path.
			 * @param {Object} rootChildren - Objek 'children' dari node project.
			 * @param {string} path - Path file yang dicari (e.g., "src/MainApp.java").
			 * @returns {Object|null} - Node file jika ditemukan, atau null.
			 */
			const findFileNodeByPath = (rootChildren, path) => {
				const parts = path.split('/');
				let currentLevel = rootChildren;
				let node = null;

				for (const part of parts) {
					if (!currentLevel || !currentLevel[part]) return null; // Path tidak valid
					node = currentLevel[part];
					currentLevel = node.children; // Lanjut ke level berikutnya
				}
				return (node && node.type === 'file') ? node : null;
			};

			window.Workspace = ({ project }) => {
				const [selectedFile, setSelectedFile] = useState(null);
				const [scrollToLine, setScrollToLine] = useState(null); // <-- State baru untuk trigger scroll
				const [citations, setCitations] = useState([]);
				const [sources, setSources] = useState([]); // State baru untuk menyimpan sumber referensi

				// --- [Hook Auto-Sitasi - UPGRADED] ---
				useEffect(() => {
					if (!project || !project.children) return;

					let processedCitations = [];
					let processedSources = {}; // Gunakan map (by normalized title) untuk de-duplikasi source
					let citationCounter = 0;

					// Fungsi rekursif untuk menjelajahi file tree
					// [PERUBAHAN]: Menambahkan 'currentPath' untuk melacak path lengkap
					const traverseAndParse = (node, currentPath) => {
						if (!node) return;
						
						// Buat path relatif untuk node ini
						const nodeRelativePath = currentPath ? `${currentPath}/${node.name}` : node.name;

						if (node.type === "file") {
							const fileType = getFileType(node.name);
							if (fileType === "python" || fileType === "java") {
								const parsedItems = parseCitationsFromCode(node.content, fileType);

								parsedItems.forEach((item) => {
									const sourceData = item.sourceData;
									if (!sourceData || !sourceData.title) {
										console.warn("Item sitasi terdeteksi tanpa sourceData atau judul.", item);
										return; // Abaikan sitasi tanpa judul
									}

									// Normalisasi judul untuk de-duplikasi
									const normalizedTitle = sourceData.title.trim().toLowerCase();
									let sourceId;

									if (processedSources[normalizedTitle]) {
										// --- Sumber SUDAH ADA (De-duplikasi) ---
										sourceId = processedSources[normalizedTitle].id;

										// LOGIKA PINTAR: Update sumber yang ada jika sitasi ini
										// menyediakan metadata (Tipe/Value) yang sebelumnya kosong.
										const existingSource = processedSources[normalizedTitle];
										if (!existingSource.type && sourceData.type) {
											existingSource.type = sourceData.type;
										}
										if (!existingSource.value && sourceData.value) {
											existingSource.value = sourceData.value;
										}
									} else {
										// --- Sumber BARU (Buat) ---
										sourceId = `auto-source-${Date.now()}-${Object.keys(processedSources).length}`;

										// Tentukan Tipe jika tidak ada:
										let type = sourceData.type;
										if (!type) {
											const valueOrTitle = sourceData.value || sourceData.title || "";
											if (valueOrTitle.match(/^https?:\/\//)) type = "url";
											else if (sourceData.value) type = "other"; // Default jika value ada tapi bukan url
											else type = "other";
										}

										// Tentukan Value jika tidak ada:
										let value = sourceData.value;
										if (!value) {
											if (type === "url" && (sourceData.title || "").match(/^https?:\/\//)) {
												value = sourceData.title; // Ambil URL dari judul (Format Cepat)
											} else if (type === "url") {
												value = "#"; // Placeholder jika tipe url tapi value kosong
											} else {
												value = "Dibuat otomatis dari komentar kode.";
											}
										}
										
										// Simpan sumber baru
										processedSources[normalizedTitle] = {
											id: sourceId,
											title: sourceData.title, // Gunakan judul asli (case-sensitive)
											type: type,
											value: value,
										};
									}

									// Buat objek sitasi baru
									const newCitation = {
										id: `auto-cite-${Date.now()}-${citationCounter++}`,
										file: nodeRelativePath, // [PERUBAHAN]: Simpan path lengkap
										start: item.start,
										end: item.end,
										code: item.code,
										note: sourceData.notes || "Sitasi ini dibuat otomatis dari komentar kode.",
										sourceId: sourceId,
										color: COLORS[citationCounter % COLORS.length],
										isEditing: false, // Langsung tampilkan (tidak dalam mode edit)
									};

									processedCitations.push(newCitation);
								});
							}
						} else if (node.type === "folder" && node.children) {
							// Rekursif ke children
							Object.values(node.children).forEach(child => traverseAndParse(child, nodeRelativePath)); // [PERUBAHAN]: Teruskan path
						}
					};

					// Mulai proses traversal dari root project (children-nya)
					// [PERUBAHAN]: Mulai dengan path kosong
					Object.values(project.children).forEach(child => traverseAndParse(child, ""));

					// Set state dengan data yang sudah diproses
					if (processedCitations.length > 0) {
						setCitations(processedCitations);
						setSources(Object.values(processedSources));
					}
				}, [project]); // Hanya jalankan saat 'project' prop berubah
				// --- [AKHIR Hook Auto-Sitasi] ---

				const handleAddCitation = (citationData) => {
					// Cek duplikasi sebelum menambahkan form baru
					const isDuplicate = citations.some(
						(c) =>
							c.file === citationData.file &&
							!c.isEditing && // Abaikan sitasi lain yang sedang diedit
							Math.max(c.start, citationData.start) <= Math.min(c.end, citationData.end)
					);
					if (isDuplicate) {
						console.error("Sebagian atau seluruh baris ini sudah disitasi.");
						return;
					}

					const newCitation = {
						id: "cite-" + Date.now(),
						...citationData,
						note: "",
						sourceId: null,
						color: COLORS[citations.length % COLORS.length],
						isEditing: true, // Mulai dalam mode edit
					};
					setCitations((prev) => [...prev, newCitation]);
				};

				const handleDeleteCitation = (citationId) => {
					setCitations((prev) => prev.filter((c) => c.id !== citationId));
				};

				const handleToggleEdit = (citationId) => {
					setCitations((prev) => prev.map((c) => (c.id === citationId ? { ...c, isEditing: true } : c)));
				};

				const handleCancelEdit = (citationId) => {
					const citation = citations.find((c) => c.id === citationId);
					// Jika sitasi belum punya sourceId, berarti ini sitasi baru yg dibatalkan, jadi hapus saja.
					if (!citation.sourceId) {
						handleDeleteCitation(citationId);
					} else {
						// Jika sudah ada, kembalikan ke mode display
						setCitations((prev) => prev.map((c) => (c.id === citationId ? { ...c, isEditing: false } : c)));
					}
				};

				const handleSaveCitation = (citationId, saveData) => {
					let newSourceId = saveData.selectedSource;
					let updatedSources = [...sources];

					if (saveData.selectedSource === "new") {
						const newSource = {
							id: "source-" + Date.now(),
							title: saveData.newSourceTitle,
							type: saveData.newSourceType,
							value: saveData.newSourceValue,
						};
						updatedSources.push(newSource);
						setSources(updatedSources);
						newSourceId = newSource.id;
					}

					const updatedCitations = citations.map((c) => {
						if (c.id === citationId) {
							return {
								...c,
								sourceId: newSourceId,
								note: saveData.note,
								isEditing: false, // Keluar dari mode edit
							};
						}
						return c;
					});
					setCitations(updatedCitations);
				};

				const handleExport = async () => {
					// Validasi: Pastikan file zip asli ada
					if (!project.originalFile) {
						console.error("File zip asli tidak tersedia. Pastikan file ini diteruskan dalam prop 'project'.");
						return;
					}

					const dataToExport = {
						sources: sources,
						// Hapus properti sementara (seperti isEditing dan color) sebelum diekspor
						citations: citations.map(({ isEditing, color, ...rest }) => rest),
					};
					const jsonString = JSON.stringify(dataToExport, null, 2);

					try {
						// INI BAGIAN KUNCINYA: Muat file zip ASLI yang diunggah
						const zip = await JSZip.loadAsync(project.originalFile);

						// Tambahkan file metadata .json ke dalam objek zip yang sudah ada
						zip.file(`${project.name}.codesite.json`, jsonString);

						// Generate file zip BARU yang sudah berisi file lama + file metadata
						const newZipBlob = await zip.generateAsync({ type: "blob" });

						// Buat nama file unik dengan timestamp
						const now = new Date();
						const pad = (num) => String(num).padStart(2, "0");
						const timestamp = `${now.getFullYear()}${pad(now.getMonth() + 1)}${pad(now.getDate())}-${pad(now.getHours())}${pad(now.getMinutes())}${pad(now.getSeconds())}`;
						const newFilename = `${project.name}-codecite-${timestamp}.zip`;

						// Memicu unduhan di browser
						const link = document.createElement("a");
						link.href = URL.createObjectURL(newZipBlob);
						link.download = newFilename;
						document.body.appendChild(link);
						link.click();
						document.body.removeChild(link);
						URL.revokeObjectURL(link.href); // Membersihkan memori
					} catch (error) {
						console.error("Gagal memproses atau membuat file zip:", error);
					}
				};

				/**
				 * [HANDLER BARU] Dipanggil saat item sitasi diklik.
				 * @param {Object} citation - Objek sitasi yang diklik.
				 */
				const handleJumpToCitation = (citation) => {
					if (!citation || !citation.file || !project.children) return;

					// Cari node file berdasarkan path lengkap (e.g., "src/MainApp.java")
					const fileNode = findFileNodeByPath(project.children, citation.file);
					
					if (fileNode) {
						// 1. Ganti file yang ditampilkan di editor
						setSelectedFile(fileNode);
						// 2. Set baris yang akan di-scroll
						setScrollToLine(citation.start);
					} else {
						console.error(`File node not found for path: ${citation.file}`);
					}
				};

				return React.createElement(
					"div",
					{ className: "bg-white p-4 rounded-lg shadow-lg h-[80vh] flex flex-col" },
					React.createElement("h2", { className: "text-xl font-bold text-gray-800 mb-4" }, "Proyek: " + project.name),
					React.createElement(
						"div",
						{ className: "grid grid-cols-1 md:grid-cols-12 gap-4 flex-1 h-[70vh]" },

						// File Explorer
						React.createElement(
							"div",
							{
								className: "col-span-12 md:col-span-3 bg-gray-100 rounded-md flex flex-col h-full overflow-y-auto",
							},
							React.createElement("h3", { className: "font-semibold p-2 sticky top-0 bg-gray-100 z-10" }, "File Explorer"),
							React.createElement(
								"div",
								{ className: "p-2" },
								React.createElement(window.FileExplorer, {
									node: project,
									onSelectFile: setSelectedFile,
								})
							)
						),

						// Code Editor
						React.createElement(window.CodeEditor, {
							file: selectedFile,
							onAddCitation: handleAddCitation,
							citations: citations.filter((c) => !c.isEditing), // Hanya kirim sitasi yg sudah disimpan ke editor
							scrollToLine: scrollToLine, // <-- [BARU] Kirim baris tujuan
							onScrollDone: () => setScrollToLine(null), // <-- [BARU] Reset trigger
						}),

						// Citation Panel
						React.createElement(
							"div",
							{
								className: "col-span-12 md:col-span-3 bg-gray-100 rounded-md flex flex-col h-full overflow-hidden",
							},

							// Header
							React.createElement(
								"div",
								{
									className: "flex justify-between items-center p-2 sticky top-0 bg-gray-100 z-10",
								},
								React.createElement("h3", { className: "font-semibold" }, "Panel Sitasi"),
								React.createElement(
									"button",
									{
										onClick: handleExport,
										className: "text-xs bg-blue-500 text-white px-2 py-1 rounded hover:bg-blue-600",
									},
									"Export Code Cite"
								)
							),

							// Info text
							React.createElement("div", { className: "text-sm text-gray-600 mb-2 px-2" }, "Klik dan drag pada kode untuk menambahkan sitasi."),

							// Scrollable list
							React.createElement(
								"div",
								{ className: "flex-1 overflow-y-auto px-2 pb-2" },
								React.createElement(
									"ul",
									{ className: "space-y-3" },
									citations.map((c) =>
										React.createElement(window.CitationItem, {
											key: c.id,
											citation: c,
											source: sources.find((s) => s.id === c.sourceId),
											allSources: sources,
											onSave: handleSaveCitation,
											onCancel: handleCancelEdit,
											onDelete: handleDeleteCitation,
											onEdit: handleToggleEdit,
											onJumpTo: handleJumpToCitation, // <-- [BARU] Kirim handler
										})
									)
								)
							)
						)
					)
				);
			};
			//==================================================
			// Component: Workspace End
			//==================================================

			//==================================================
			// Component: File Explorer
			//==================================================
			window.FileExplorer = ({ node, onSelectFile }) => {
				const [expanded, setExpanded] = useState(true);

				if (node.type === "file") {
					return React.createElement(
						"div",
						{
							className: "pl-4 py-1 cursor-pointer hover:bg-gray-200 rounded",
							onClick: () => onSelectFile(node),
						},
						`ðŸ“„ ${node.name}`
					);
				}

				return React.createElement(
					"div",
					{ className: "pl-2" },
					React.createElement(
						"div",
						{
							className: "font-semibold cursor-pointer flex items-center hover:bg-gray-200 rounded px-1",
							onClick: () => setExpanded(!expanded),
						},
						`${expanded ? "ðŸ“‚" : "ðŸ“"} ${node.name}`
					),

					expanded &&
						React.createElement(
							"div",
							{ className: "pl-4" },
							Object.values(node.children).map((child) =>
								React.createElement(FileExplorer, {
									key: child.name,
									node: child,
									onSelectFile: onSelectFile,
								})
							)
						)
				);
			};

			//==================================================
			// Component: File Explorer End
			//==================================================

			//==================================================
			// Component: Code Editor
			//==================================================
			window.CodeEditor = ({ file, onAddCitation, citations, scrollToLine, onScrollDone }) => {
				const [lines, setLines] = useState([]);
				const [dragStart, setDragStart] = useState(null);
				const [dragEnd, setDragEnd] = useState(null);
				const [isDragging, setIsDragging] = useState(false);

				const editorRef = useRef(null);
				const rafRef = useRef(null);
				const lastMouseEventRef = useRef(null);

				// Refs untuk data supaya handler global bisa mengakses nilai terbaru
				const linesRef = useRef([]);
				const dragStartRef = useRef(null);
				const dragEndRef = useRef(null);
				const isDraggingRef = useRef(false);
				const onAddCitationRef = useRef(onAddCitation);

				useEffect(() => {
					onAddCitationRef.current = onAddCitation;
				}, [onAddCitation]);

				useEffect(() => {
					linesRef.current = lines;
				}, [lines]);

				useEffect(() => {
					dragStartRef.current = dragStart;
				}, [dragStart]);

				useEffect(() => {
					dragEndRef.current = dragEnd;
				}, [dragEnd]);

				useEffect(() => {
					isDraggingRef.current = isDragging;
				}, [isDragging]);

				// --- [EFEK BARU] UNTUK AUTO-SCROLL ---
				useEffect(() => {
					if (scrollToLine && editorRef.current && lines.length > 0) {
						// Cari elemen barisnya
						const lineElement = editorRef.current.querySelector(`[data-line="${scrollToLine}"]`);
						
						if (lineElement) {
							// Lakukan scroll
							lineElement.scrollIntoView({
								behavior: "smooth",
								block: "center", // Posisikan di tengah layar
							});

							// Tambahkan efek highlight "flash"
							lineElement.classList.add("flash-highlight");
							setTimeout(() => {
								if (lineElement) {
									lineElement.classList.remove("flash-highlight");
								}
							}, 1500); // Durasi flash 1.5 detik
						}
						
						// Beri tahu parent bahwa scroll sudah selesai (atau setidaknya sudah di-trigger)
						onScrollDone();
					}
				}, [scrollToLine, file, lines]); // Bergantung pada scrollToLine, file, dan render 'lines'
				// --- [AKHIR EFEK BARU] ---


				const handleGlobalMouseUp = (e) => {
					if (isDraggingRef.current && dragStartRef.current != null && dragEndRef.current != null) {
						const start = Math.min(dragStartRef.current, dragEndRef.current);
						const end = Math.max(dragStartRef.current, dragEndRef.current);
						
						// [PERBAIKAN]: Ambil path lengkap dari 'file.name'
						// Kita asumsikan 'file' object sekarang berisi path
						// Mari kita cek 'buildFileTree'.
						// `current[part] = { name: part, type: "file", content };`
						// Oh, `file.name` HANYA NAMA. Path lengkap harusnya ada di...
						// `selectedFile` di `Workspace` adalah `fileNode`.
						// `fileNode` punya `name` dan `type` dan `content`.
						// Path-nya tidak disimpan di node.
						//
						// SOLUSI: `onAddCitation` harus mengambil path dari `file` object.
						// Mari kita asumsikan `file.path` akan ada.
						// Tidak, `buildFileTree` tidak menambahkannya.
						//
						// SOLUSI SEMENTARA: Kita harus menggunakan `file.name` saja
						// TAPI `selectedFile` di `Workspace` adalah `fileNode`
						// Mari kita modifikasi `FileExplorer` untuk mengirim `node` utuh
						// `onSelectFile: setSelectedFile` -> ini sudah mengirim node utuh
						//
						// Masalahnya ada di `handleAddCitation`
						// `c.file === citationData.file`
						// `citationData.file` harusnya path lengkap.
						//
						// Kita perlu `file.path` di sini.
						// Mari kita asumsikan `file` yang diterima `CodeEditor`
						// adalah `fileNode` yang memiliki `path`
						
						// Mari kita ubah `buildFileTree` untuk menyimpan path
						// (Ini akan dilakukan di 'App' component)

						const codeBlock = linesRef.current.slice(start - 1, end).join("\n");
						if (onAddCitationRef.current) {
							onAddCitationRef.current({
								file: file.path, // <-- [PERUBAHAN PENTING] Asumsikan file.path ada
								start,
								end,
								code: codeBlock,
							});
						}
					}
					resetDrag();
				};

				// Gunakan useRef untuk menyimpan referensi stabil ke handleGlobalMouseUp
				const globalMouseUpHandlerRef = useRef(handleGlobalMouseUp);
				useEffect(() => {
					globalMouseUpHandlerRef.current = handleGlobalMouseUp;
				}, [file, lines]); // Update jika dependensi berubah

				const resetDrag = () => {
					setDragStart(null);
					setDragEnd(null);
					setIsDragging(false);
					window.removeEventListener("mouseup", globalMouseUpHandlerRef.current);
				};

				useEffect(() => {
					if (file) {
						setLines(file.content.split("\n"));
						resetDrag();
					} else {
						setLines([]);
					}
					return () => {
						if (rafRef.current) cancelAnimationFrame(rafRef.current);
						window.removeEventListener("mouseup", globalMouseUpHandlerRef.current);
					};
				}, [file]);

				const handleMouseDown = (lineNumber) => {
					setDragStart(lineNumber);
					setDragEnd(lineNumber);
					setIsDragging(true);
					window.addEventListener("mouseup", globalMouseUpHandlerRef.current);
				};

				const handleMouseEnter = (lineNumber) => {
					if (isDragging) {
						setDragEnd(lineNumber);
					}
				};

				const updateDragEndFromPoint = (clientX, clientY) => {
					const editor = editorRef.current;
					if (!editor) return;

					let el = document.elementFromPoint(clientX, clientY);
					if (el) {
						const lineEl = el.closest(".code-line");
						if (lineEl && lineEl.dataset && lineEl.dataset.line) {
							const ln = Number(lineEl.dataset.line);
							setDragEnd(ln);
							return;
						}
					}
				};

				const handleMouseMove = (e) => {
					if (!isDragging) return;
					lastMouseEventRef.current = e;
					if (rafRef.current) return;

					rafRef.current = requestAnimationFrame(() => {
						rafRef.current = null;
						const ev = lastMouseEventRef.current;
						if (!ev || !editorRef.current) return;

						const rect = editorRef.current.getBoundingClientRect();
						const zone = 60;
						const maxSpeed = 35;
						const speedFactor = 3.5;
						const topEdge = rect.top + zone;
						const bottomEdge = rect.bottom - zone;

						if (ev.clientY < topEdge) {
							const distance = Math.max(1, topEdge - ev.clientY);
							const speed = Math.min(maxSpeed, distance / speedFactor);
							editorRef.current.scrollTop -= speed;
						} else if (ev.clientY > bottomEdge) {
							const distance = Math.max(1, ev.clientY - bottomEdge);
							const speed = Math.min(maxSpeed, distance / speedFactor);
							editorRef.current.scrollTop += speed;
						}
						updateDragEndFromPoint(ev.clientX, ev.clientY);
					});
				};

				const handleMouseUp = (e) => {
					globalMouseUpHandlerRef.current(e);
				};

				const getHighlightColor = (lineNumber) => {
					// Cari sitasi yang *aktif* (non-editing)
					const activeCitations = citations.filter((c) => c.file === file.path); // <-- [PERUBAHAN PENTING] Asumsikan file.path

					for (const c of activeCitations) {
						if (lineNumber >= c.start && lineNumber <= c.end) {
							return c.color;
						}
					}

					// Highlight untuk *dragging* manual
					if (isDragging && dragStart != null && dragEnd != null) {
						const start = Math.min(dragStart, dragEnd);
						const end = Math.max(dragStart, dragEnd);
						if (lineNumber >= start && lineNumber <= end) {
							return "bg-cyan-900/40";
						}
					}
					return "";
				};

				if (!file) {
					return React.createElement("div", { className: "col-span-12 md:col-span-6 bg-[#282c34] rounded-md flex flex-col h-full overflow-y-auto items-center justify-center text-gray-400" }, "Pilih file untuk ditampilkan");
				}

				return React.createElement(
					"div",
					{
						className: "col-span-12 md:col-span-6 bg-[#282c34] rounded-md flex flex-col h-full overflow-hidden font-mono text-sm select-none",
						onMouseUp: handleMouseUp,
						onMouseMove: handleMouseMove,
					},
					React.createElement("div", { className: "bg-gray-700 text-white p-2 rounded-t-md flex-shrink-0" }, file.path), // <-- [PERUBAHAN PENTING] Tampilkan path
					React.createElement(
						"div",
						{
							ref: editorRef,
							className: "flex-1 overflow-auto text-gray-200",
						},
						lines.map((line, i) => {
							const lineNumber = i + 1;
							const highlightClass = getHighlightColor(lineNumber) || "hover:bg-gray-700/50";
							return React.createElement(
								"div",
								{
									key: i,
									"data-line": lineNumber,
									className: `code-line flex group cursor-pointer ${highlightClass}`,
									onMouseDown: () => handleMouseDown(lineNumber),
									onMouseEnter: () => handleMouseEnter(lineNumber),
								},
								React.createElement("div", { className: "w-12 text-right pr-4 text-gray-500 select-none sticky left-0 bg-[#282c34]" }, lineNumber),
								React.createElement(
									"pre",
									{ className: "flex-1 whitespace-pre-wrap py-0 px-2" },
									React.createElement("code", {
										dangerouslySetInnerHTML: {
											__html: hljs.highlight(line, { language: file.name.split(".").pop(), ignoreIllegals: true }).value,
										},
									})
								)
							);
						})
					)
				);
			};

			//==================================================
			// Component: Code Editor End
			//==================================================

			//==================================================
			// Component: Citetation Item
			//==================================================
			window.CitationItem = ({ citation, source, allSources, onSave, onCancel, onDelete, onEdit, onJumpTo }) => {
				// State untuk form di dalam item ini
				const [selectedSource, setSelectedSource] = useState("new");
				const [newSourceTitle, setNewSourceTitle] = useState("");
				const [newSourceType, setNewSourceType] = useState("url");
				const [newSourceValue, setNewSourceValue] = useState("");
				const [note, setNote] = useState(citation.note || "");

				// useEffect untuk me-reset form state saat mode edit diaktifkan
				useEffect(() => {
					if (citation.isEditing) {
						// Jika sitasi sudah punya sumber, set dropdown ke sumber tsb
						if (citation.sourceId) {
							setSelectedSource(citation.sourceId);
						} else {
							setSelectedSource("new");
						}
						setNote(citation.note || "");
						// Reset form 'new source'
						setNewSourceTitle("");
						setNewSourceType("url");
						setNewSourceValue("");

						// Jika sitasi dibuat otomatis DAN belum diedit manual,
						// coba isi form 'new source' dari data sitasi.
						if (citation.id.startsWith("auto-cite-") && source) {
							// Jika ini sitasi otomatis, kita ingin pengguna
							// mengonfirmasi/mengedit sumber yang dibuat otomatis.
							// Kita set dropdown ke 'new' dan isi field-nya.
							setSelectedSource("new");
							setNewSourceTitle(source.title);
							setNewSourceType(source.type);
							setNewSourceValue(source.value);
						}
					}
				}, [citation.isEditing, citation.sourceId, citation.note, allSources, source]);

				const handleSaveClick = () => {
					// Validasi: Judul wajib diisi jika membuat sumber baru
					if (selectedSource === "new" && !newSourceTitle.trim()) {
						// Di aplikasi nyata, gunakan UI non-blocking, bukan alert.
						console.error("Judul referensi wajib diisi saat membuat sumber baru.");
						return;
					}

					// Cek apakah ini sitasi otomatis yang sedang diedit
					const isAutoCitationEdit = citation.id.startsWith("auto-cite-");

					onSave(citation.id, {
						selectedSource,
						newSourceTitle,
						newSourceType,
						newSourceValue,
						note,
						// Jika ini edit pertama dari sitasi otomatis, kita mungkin
						// ingin menghapus sumber otomatis lamanya jika tidak ada
						// sitasi lain yang menggunakannya.
						// (Logika ini bisa ditambahkan di 'handleSaveCitation' di Workspace)
					});
				};

				// Tampilan Mode Edit
				if (citation.isEditing) {
					return React.createElement(
						"li",
						{ className: "bg-white shadow-md p-3 rounded-lg border text-xs space-y-2" },
						// Dropdown Pemilihan Sumber
						React.createElement(
							"div",
							null,
							React.createElement("label", { className: "block font-medium mb-1" }, "Sumber Referensi"),
							React.createElement(
								"select",
								{
									value: selectedSource,
									onChange: (e) => setSelectedSource(e.target.value),
									className: "w-full border p-1 rounded",
								},
								React.createElement("option", { value: "new" }, "--- Buat / Edit Sumber ---"),
								// Filter 'allSources' agar tidak menampilkan sumber otomatis
								// yang terkait DENGAN sitasi ini (jika ada)
								allSources
									.filter((s) => s.id !== citation.sourceId || !citation.id.startsWith("auto-cite-"))
									.map((s) => React.createElement("option", { key: s.id, value: s.id }, s.title))
							)
						),

						// Form untuk Sumber Baru (muncul kondisional)
						selectedSource === "new" &&
							React.createElement(
								"div",
								{ className: "border p-2 rounded space-y-2 bg-gray-50" },
								React.createElement("input", {
									type: "text",
									placeholder: "Judul / ID Referensi (e.g., Gemini, StackOverflow)",
									value: newSourceTitle,
									onChange: (e) => setNewSourceTitle(e.target.value),
									className: "w-full border p-1 rounded",
								}),
								React.createElement(
									"select",
									{
										value: newSourceType,
										onChange: (e) => setNewSourceType(e.target.value),
										className: "w-full border p-1 rounded",
									},
									React.createElement("option", { value: "url" }, "Link / URL"),
									React.createElement("option", { value: "ai" }, "AI (Kecerdasan Buatan)"),
									React.createElement("option", { value: "other" }, "Lainnya (Teks)")
								),
								newSourceType === "url" &&
									React.createElement("input", { type: "text", placeholder: "https://example.com", value: newSourceValue, onChange: (e) => setNewSourceValue(e.target.value), className: "w-full border p-1 rounded" }),
								newSourceType === "ai" &&
									React.createElement("input", { type: "text", placeholder: "e.g., ChatGPT 4, Gemini", value: newSourceValue, onChange: (e) => setNewSourceValue(e.target.value), className: "w-full border p-1 rounded" }),
								newSourceType === "other" &&
									React.createElement("textarea", { placeholder: "e.g., Bantuan dari teman, kode dari tugas lama", value: newSourceValue, onChange: (e) => setNewSourceValue(e.target.value), className: "w-full border p-1 rounded", rows: 2 })
							),

						// Kolom Catatan
						React.createElement(
							"div",
							null,
							React.createElement("label", { className: "block font-medium mb-1" }, "Catatan (Notes)"),
							React.createElement("textarea", {
								value: note,
								onChange: (e) => setNote(e.target.value),
								placeholder: "Tambahkan detail, misal: prompt yang digunakan...",
								className: "w-full border p-1 rounded text-gray-700",
								rows: 3,
							})
						),

						// Tombol Aksi
						React.createElement(
							"div",
							{ className: "flex justify-end space-x-2 pt-2" },
							React.createElement("button", { onClick: () => onCancel(citation.id), className: "bg-gray-200 hover:bg-gray-300 px-3 py-1 rounded" }, "Batal"),
							React.createElement("button", { onClick: handleSaveClick, className: "bg-cyan-600 text-white hover:bg-cyan-700 px-3 py-1 rounded" }, "Simpan")
						)
					);
				}

				// Tampilan Mode Normal (Display)
				return React.createElement(
					"li",
					{
						key: citation.id,
						className: "bg-white shadow-sm p-3 rounded-md border text-xs space-y-1",
					},
					React.createElement(
						"div",
						{ className: "flex justify-between items-start" },
						React.createElement(
							"div",
							null,
							React.createElement("strong", { className: "text-sm" }, source ? source.title : React.createElement("span", { className: "text-red-500" }, "Sumber belum diatur")),
							React.createElement("div", { className: "text-gray-500 text-[11px]" }, `(${source ? source.type : "N/A"})`)
						),
						React.createElement(
							"div",
							{ className: "flex space-x-2" },
							React.createElement("button", { onClick: () => onEdit(citation.id), className: "text-blue-500 text-xs hover:underline" }, "Ubah"),
							React.createElement("button", { onClick: () => onDelete(citation.id), className: "text-red-500 text-xs hover:underline" }, "Hapus")
						)
					),
					// [PERUBAHAN]: Teks ini sekarang clickable
					React.createElement(
						"div",
						{
							className: "text-gray-600 font-semibold cursor-pointer hover:text-cyan-600 hover:underline",
							onClick: () => onJumpTo(citation), // <-- AKSI BARU
						},
						`${citation.file} (Baris ${citation.start}${citation.end !== citation.start ? `â€“${citation.end}` : ""})`
					),
					React.createElement("pre", { className: "bg-gray-100 p-1.5 rounded mt-1 overflow-x-auto text-[11px]" }, React.createElement("code", null, citation.code)),
					citation.note && React.createElement("div", { className: "mt-1 pt-1 border-t" }, React.createElement("p", { className: "whitespace-pre-wrap" }, citation.note))
				);
			};

			//==================================================
			// Component: Citetation Item End
			//==================================================

			//==================================================
			// Component: App
			//==================================================
			const App = () => {
				const [project, setProject] = useState(null);

				// [PERUBAHAN]: buildFileTree sekarang menyimpan path lengkap di node
				const buildFileTree = async (files) => {
					const root = {};
					for (const relativePath in files) {
						if (files[relativePath].dir) continue;

						const parts = relativePath.split("/").filter((p) => p);
						let current = root;

						for (let i = 0; i < parts.length; i++) {
							const part = parts[i];
							const isFile = i === parts.length - 1;
							const currentPath = parts.slice(0, i + 1).join('/');

							if (isFile) {
								const content = await files[relativePath].async("string");
								current[part] = { 
									name: part, 
									path: currentPath, // <-- [BARU] Simpan path lengkap
									type: "file", 
									content 
								};
							} else {
								current[part] = current[part] || { 
									name: part, 
									path: currentPath, // <-- [BARU] Simpan path lengkap
									type: "folder", 
									children: {} 
								};
								current = current[part].children;
							}
						}
					}
					return root;
				};

				const handleUpload = async (file, projectName) => {
					try {
						const zip = await JSZip.loadAsync(file);
						const fileTree = await buildFileTree(zip.files);

						setProject({
							name: projectName,
							children: fileTree,
							type: "folder",
							originalFile: file,
						});
					} catch (error) {
						console.error("Gagal memproses file zip:", error);
					}
				};

				return (
					// Mengubah div terluar menjadi flex container dengan tinggi seukuran layar
					React.createElement(
						"div",
						{ className: "flex flex-col h-screen bg-gray-100" },
						React.createElement(window.Header),
						React.createElement(window.Navbar),
						// "main" akan mengisi sisa ruang yang tersedia dan menangani overflow internal
						React.createElement(
							"main",
							{ className: "px-6 py-6 flex-1 overflow-hidden" },
							!project
								? React.createElement(window.UploadScreen, { onUpload: handleUpload })
								: // Workspace sekarang akan mengisi area 'main' ini sepenuhnya
								  React.createElement(window.Workspace, { project: project })
						)
					)
				);
			};

			ReactDOM.render(React.createElement(App), document.getElementById("root"));

			//==================================================
			// Component: App End
			//==================================================
		</script>
	</body>
</html>

